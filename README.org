#+title: Complete intro to SQLite using Node
#+date: [2025-02-14 Fri]
#+startup: indent
#+property: header-args :results output

* üè∑Ô∏è Complete-Intro-to-SQLite
Front End Masters [[https://frontendmasters.com/courses/sqlite/][course]] by Brian Holt.

* Node app
Since the last version of *Node*, as of today, support TS, I'll just let the IDE
handle the types and run without transpiling.
In the root of the folder:
#+begin_src bash
  nvm install 23
  npm init -y
#+end_src

Some basic settings to begin with:
- Main entry point is =index.ts=. I write directly in typescript and let *Node*
  do the stripping. I will probably have to use only a subset of the TS features
  available.
- Tests will run with the built in test runner ~node --test~.
  *Node* will run against any file that ends with =.test.ts=


Because Typescript doesn't understand *Node* types, I need to also install them.
#+name: install node types
#+begin_src bash
  npm i -D @types/node
#+end_src
* üîë Env
It's all done locally, so no need of handling API Keys of any sort.
* Sqlite command sample
License from *sqlite* is coming from the [[https://github.com/lerocha/chinook-database/blob/master/LICENSE.md][sqlite-repo]].
we assume you have the database opened ~sqlite3 ./Chinook_Sqlite.sqlite~.
** Basic builtin commands
- .help :: show the builtin commands available
- .show :: Show the current values for various settings
- .excel :: Display the output of next command in spreadsheet[fn:1]
- .fullschema :: Show schema and the content of sqlite_stat tables
- .schema <pattern> :: Show the CREATE statements matching <pattern>[fn:2]
- .tables <pattern> :: List names of tables matching LIKE pattern TABLE
** SQL commands
I will write the commands in lower case, and respect the schema for table names
and column names (i.e. Same case and between brackets: [Artist]).
There is this rule that says:
- single quotes for strings
- double quotes fol column names
Since I want to use [] for column names, there is simply one rule:
- no double quotes

#+name: open session
#+description: open sqlite session with the Chinook database
#+begin_src bash
  sqlite3 ./Chinook_Sqlite.sqlite
#+end_src

#+name: select
#+begin_src sql
  select * from [Artist]
  select name from [Artist] where [ArtistId] = 174;
  select * from [Artist] where [Name] like '%Postal%';
  select * from [Artist] order by [Name] desc limit 10;
  -- pagination
  select * from [Artist] limit 10; -- page 1
  select * from [Artist] limit 10 offset 10; -- page 2
  select * from [Artist] limit 10 offset 20; -- page 3
#+end_src
** Node:sqlite commands
See [[https://nodejs.org/docs/latest/api/sqlite.html#statementallnamedparameters-anonymousparameters][statement.all]] for an example.

The order of execution is:
1. DatabaseSync with the path to database or ~inMemory~
2. Prepare a request (or any SQL command) into a ~statement~
3. Execute the statement, with:
   - statement.get() :: fetch the first object in the array
   - statement.iterate() :: returns an iterator
   - statement.all() :: returns an array

#+name: example of simlpe node:sqlite statement
#+begin_src javascript
  import { DatabaseSync } from 'node:sqlite'

  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')
  const allPostals = chinookDB.prepare('select * from [Artist] where [Name] like \'%Postal%\'')
  allPostals.all().forEeach(artist => {
    console.info(artist)
  })
#+end_src
* Insert Commands
The [Artist] table has the following schema:
#+name: artist schema
#+begin_src sql
  CREATE TABLE [Artist]
  (
      [ArtistId] INTEGER  NOT NULL,
      [Name] NVARCHAR(120),
      CONSTRAINT [PK_Artist] PRIMARY KEY  ([ArtistId])
  );
#+end_src
The [ArtistId] is generated, so adding a new entry means inserting a new [Name].

#+name: number of entries in [Artist]
#+begin_src sql
  sqlite> select count(*) from [Artist]
  275
#+end_src
** SQL commands
Let's add *Radiohead* to the table
#+name: insert Radiohead
#+begin_src sql
sqlite> insert into [Artist] (name) values ('Radiohead');
#+end_src
No feedback in term of successful insertion ü§∑üèª.

#+name: list last entries
#+begin_src sql
  sqlite> select * from [Artist] order by [ArtistId] desc limit 5;
  276|Radiohead
  275|Philip Glass Ensemble
  274|Nash Ensemble
  273|C. Monteverdi, Nigel Rogers - Chiaroscuro; London Baroque; London Cornett & Sackbu
  272|Emerson String Quartet
#+end_src

** Node:sqlite commands
Does the artist already exist?
#+name: checking duplicates
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')

  const prepFindArtist = chinookDB.prepare(`select * from [Artist] where [Name] = ?`)
  const artistsFound = prepFindArtist.all(name)

  assert.ok(artistsFound.length === 0)
#+end_src

If not then we can add the entry to the table.
#+name: add daft punk
#+begin_src javascript
  const name = 'DaftPunk'
  const prepInsert = chinookDB.prepare(`insert into [Artist] (name) values (?)`)
  const insertLog = prepInsert.run(name)
  console.log(insertLog)
#+end_src

* Update Commands
We want to replace an entry from the [Artist] table.

** SQL command
#+name: from Radiohead to DaftPunk
#+begin_src sql
  sqlite> update [Artist] set [Name] = 'Daft Punk' where [Name] = 'Radiohead' -- Doesn't return anything
  sqlite> update [Artist] set [Name] = 'Justice' where [Name] = 'Daft Punk' returning * -- returns the updated entry
#+end_src


** Node:sqlite commands
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')

  const prepUpdate = chinookDB.prepare('update [Artist] set [Name] = ? where [Name] = ?')
  const updateLog = prepUpdate.run('Daft Punk', 'Radiohead')
  console.log(updateLog)

  chinookDB.close()
#+end_src

* Delete Commands
Let's remove *Radiohead*.

** SQL command
#+name: remove DaftPunk_
#+begin_src sql
  sqlite> delete from [Artist] where [Name] = 'DaftPunk_' returning *;
  278|DaftPunk_
#+end_src

** Node:sqlite command
#+name: remove Justice
#+begin_src javascript
  const name = 'Justice'
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')
  const prepDelete = chinookDB.prepare('delete from [Artist] where [Name] = ? returning *')
  const deleteLog = prepDelete.all(name)
#+end_src

* Creating Tables
There are only 4 datatypes in *SQLite*:
- NULL :: null value
- INTEGER :: signed Int
- REAL :: Floading point value
- TEXT :: text string
- BLOB :: blob of data, like pictures or sound

See [[https://www.sqlite.org/datatype3.html][datatype]] doc.

** SQL command
#+name: creating table and adding a record
#+begin_src sql
  create table [BandMember] (
    [Id]   integer primary key, -- used as rowid
    [Name] text    unique not null,
    [Role] text
  );
  insert into
    [BandMember]
    ([Name], [Role])
  values
    ('Thom Yorke', 'singer'),
    ('Colin Greenwood', 'bassist'),
    ('Ed O''Brien', 'guitarist'),
    ('Philip Selway', 'drummer')
  returning *;
#+end_src

Add a column and drop a column
#+begin_src sql
  alter table [BandMember] add column [Image] BLOB;
  alter table [BandMember] drop column [Image];
  alter table [BandMember] add column [Nationality] TEXT NOT NULL DEFAULT 'UK';
#+end_src

Remove a table
#+begin_src sql
  drop table [BandMember];
#+end_src

* Relational data & Join
The Album table has the following schema:
#+begin_src sql
  sqlite> .schema album
  CREATE TABLE [Album]
  (
      [AlbumId] INTEGER  NOT NULL,
      [Title] NVARCHAR(160)  NOT NULL,
      [ArtistId] INTEGER  NOT NULL,
      CONSTRAINT [PK_Album] PRIMARY KEY  ([AlbumId]),
      FOREIGN KEY ([ArtistId]) REFERENCES [Artist] ([ArtistId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON [Album] ([ArtistId]);
#+end_src

The first few rows look like:
#+begin_src sql
  sqlite> select * from [Album] limit 10;
  1|For Those About To Rock We Salute You|1
  2|Balls to the Wall|2
  3|Restless and Wild|2
  4|Let There Be Rock|1
  5|Big Ones|3
  6|Jagged Little Pill|4
  7|Facelift|5
  8|Warner 25 Anos|6
  9|Plays Metallica By Four Cellos|7
  10|Audioslave|8
#+end_src

The last number is the [ArtistId], that matches the [Artist] ([ArtistId]).
To display the [Name] of the artist instead of the ID:
#+begin_src sql
  sqlite> select Album.AlbumId, Album.Title, Artist.Name
     ...> from [Album] join [Artist] on Album.ArtistId = Artist.ArtistId
     ...> limit 10;
  1|For Those About To Rock We Salute You|AC/DC
  2|Balls to the Wall|Accept
  3|Restless and Wild|Accept
  4|Let There Be Rock|AC/DC
  5|Big Ones|Aerosmith
  6|Jagged Little Pill|Alanis Morissette
  7|Facelift|Alice In Chains
  8|Warner 25 Anos|Ant√¥nio Carlos Jobim
  9|Plays Metallica By Four Cellos|Apocalyptica
  10|Audioslave|Audioslave
#+end_src

** Table alias
Typing the name of the albums all the time can be cumbersome.
There different types of alias:
#+begin_src sql
  sqlite> select Alb.AlbumId, Alb.Title, Art.Name as [artName]
     ...> from [Album] [Alb] join [Artist] [Art] on Alb.ArtistId = Art.ArtistId
     ...> where [artName] = 'Nirvana'
     ...> limit 10;
  163|From The Muddy Banks Of The Wishkah [Live]|Nirvana
  164|Nevermind|Nirvana
#+end_src

** Multiple join
#+begin_src sql
  select art.Name, alb.Title as [Title], trk.Name
  from [Album] [alb]
  join [Artist] [art] on art.ArtistId = alb.ArtistId
  join [Track] [trk]  on trk.AlbumId = alb.AlbumId
  where [Title] = 'Nevermind';
#+end_src

By default this is an *Inner Join*.
- Inner Join :: Include only if this is in both
- Left :: All of *From* table
- Right :: All of the *Join* table
  # You probably don't want to use that one üëáüèª
- Full Outer :: Include all records no matter

*Snow Patrol*:
- has a record in the [Artist] table but
- not in the [Album] table

#+begin_src sql
  sqlite> select * from [Artist] where [Name] = 'Snow Patrol';
  172|Snow Patrol
  sqlite> select * from [Album] where [ArtistId] = 172;
  -- null
#+end_src

With *INNER JOIN*:
#+begin_src sql
  sqlite> select art.Name as [Name], alb.Title
     ...> from [Album] [alb]
     ...> inner join [Artist] [art]
     ...>   on art.ArtistId = alb.ArtistId
     ...> where [Name] = 'Snow Patrol';
  -- null
#+end_src

Same but *RIGHT JOIN*:
#+begin_src sql
  sqlite> select art.Name as [Name], alb.Title
     ...> from [Album] [alb]
     ...> right join [Artist] [art] -- Right Outer Join
     ...>   on art.ArtistId = alb.ArtistId
     ...> where [Name] = 'Snow Patrol';
  Snow Patrol|                    -- There is an art.Name but no alb.Title
#+end_src

List all the artists that do not have an album:
#+begin_src sql
  select art.Name, alb.Title
  from [Artist] [art]
  left outer join [Album] [alb]
    on alb.ArtistId = art.ArtistId
  where alb.ArtistId is null;
#+end_src


* Foreign Keys
They're not enforced by default[fn:3]
See [[https://www.sqlite.org/foreignkeys.html][SQLite Foreign Key Support]].

Enforce foreign key constraint by typing ~sqlite> pragma foreign_keys = on~
#+begin_src sql
  sqlite> .schema Track
  CREATE TABLE [Track]
  (
      [TrackId] INTEGER  NOT NULL,
      [Name] NVARCHAR(200)  NOT NULL,
      [AlbumId] INTEGER,
      [MediaTypeId] INTEGER  NOT NULL,
      [GenreId] INTEGER,
      [Composer] NVARCHAR(220),
      [Milliseconds] INTEGER  NOT NULL,
      [Bytes] INTEGER,
      [UnitPrice] NUMERIC(10,2)  NOT NULL,
      CONSTRAINT [PK_Track] PRIMARY KEY  ([TrackId]),
      FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION,
      FOREIGN KEY ([GenreId]) REFERENCES [Genre] ([GenreId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION,
      FOREIGN KEY ([MediaTypeId]) REFERENCES [MediaType] ([MediaTypeId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION
  );
  CREATE INDEX [IFK_TrackAlbumId] ON [Track] ([AlbumId]);
  CREATE INDEX [IFK_TrackGenreId] ON [Track] ([GenreId]);
  CREATE INDEX [IFK_TrackMediaTypeId] ON [Track] ([MediaTypeId]);

  sqlite> pragma foreign_keys = on;
  sqlite> insert into [Track] ([Name], [AlbumId], [MediaTypeId], [GenreId], [Composer], [Milliseconds], [Bytes], [UnitPrice])
     ...> values ('lol', 9999, 9999, 9999, 9999, 9999, 9999, 9999);
  Runtime error: FOREIGN KEY constraint failed (19)
#+end_src

*AlbumId* is a foreign key
#+begin_src sql
FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
            ON DELETE NO ACTION ON UPDATE NO ACTION,
#+end_src
Looking at the schema, it means to add a new track, you need to ensure that:
- the [AlbumId] value matches an existing [Album] ([AlbumId])
- the [GenreId] value matches an existing [Genre] ([GenreId])
- the [MediaTypeId] value matches an existing [MediaType] ([MediaTypeId])
Since we're adding a Track with the AlbumId 9999 that doesn't exist, it fails.


** Node:sqlite && foreign keys
By default SQLite doesn't enforce foreign keys but *Node:sqlite* does.
See [[https://nodejs.org/docs/latest/api/sqlite.html#new-databasesynclocation-options][DatabaseSync options]]
#+begin_quote
~enableForeignKeyConstraints <boolean>~
If ~true~, foreign key constraints are enabled.
This is recommended but can be disabled for compatibility with legacy database
schemas. The enforcement of foreign key constraints can be enabled and disabled
after opening the database using ~PRAGMA foreign_keys~. Default: ~true~.
#+end_quote

To disable the foreign key constraints:
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite', {
      enableForeignKeyConstraints: false
  })
  // To enable it after opening the database:
const prep = chinookDB.prepare('PRAGMA foreign_keys = ON')
#+end_src

* Aggregation
** count and distinct
#+begin_src sql
sqlite> select count(*) from [Track];
3503
sqlite> select count(distinct [GenreId]) from [Track];
25 -- There are 25 genres
-- How many tracks, per genre?
sqlite> select [GenreId], count([GenreId]) as [Count]
   ...> from [Track]
   ...> group by [GenreId]
   ...> order by [Count] desc;
1|1297
7|579
3|374
4|332
2|130
19|93
6|81
24|74
21|64
14|61
8|58
9|48
10|43
23|40
17|35
15|30
13|28
16|28
20|26
12|24
22|17
11|15
18|13
5|12
25|1
-- Name of the genre instead of the Id
sqlite> select Genre.Name, count(Track.GenreId) as [Count]
   ...> from [Track]
   ...> right join [Genre] on Track.GenreId = Genre.GenreId
   ...> group by Track.GenreId
   ...> order by [Count] desc;
Rock|1297
Latin|579
Metal|374
Alternative & Punk|332
Jazz|130
TV Shows|93
Blues|81
Classical|74
Drama|64
R&B/Soul|61
Reggae|58
Pop|48
Soundtrack|43
Alternative|40
Hip Hop/Rap|35
Electronica/Dance|30
World|28
Heavy Metal|28
Sci Fi & Fantasy|26
Easy Listening|24
Comedy|17
Bossa Nova|15
Science Fiction|13
Rock And Roll|12
Opera|1
#+end_src

** TODO Having[fn:4]
It's ~WHERE~ once the aggregation happened. You cannot refer to any aggregated
value in the ~WHERE~ clause.
#+begin_src sql
sqlite> select Track.GenreId, Genre.Name, count(Track.GenreId) as [Count]
   ...> from [Track]
   ...> join [Genre] on Genre.GenreId = Track.GenreId
   ...> group by Track.GenreId
   ...> Having [Count] > 300;
1|Rock|1297
3|Metal|374
4|Alternative & Punk|332
7|Latin|579
#+end_src

* Subqueries
List the Invoices coming from the same Customer:
#+begin_src sql
sqlite> .schema invoice
CREATE TABLE [Invoice]
(
    [InvoiceId] INTEGER  NOT NULL,
    [CustomerId] INTEGER  NOT NULL,
    [InvoiceDate] DATETIME  NOT NULL,
    [BillingAddress] NVARCHAR(70),
    [BillingCity] NVARCHAR(40),
    [BillingState] NVARCHAR(40),
    [BillingCountry] NVARCHAR(40),
    [BillingPostalCode] NVARCHAR(10),
    [Total] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Invoice] PRIMARY KEY  ([InvoiceId]),
    FOREIGN KEY ([CustomerId]) REFERENCES [Customer] ([CustomerId]) 
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_InvoiceCustomerId] ON [Invoice] ([CustomerId]);
sqlite> .schema customer
CREATE TABLE [Customer]
(
    [CustomerId] INTEGER  NOT NULL,
    [FirstName] NVARCHAR(40)  NOT NULL,
    [LastName] NVARCHAR(20)  NOT NULL,
    [Company] NVARCHAR(80),
    [Address] NVARCHAR(70),
    [City] NVARCHAR(40),
    [State] NVARCHAR(40),
    [Country] NVARCHAR(40),
    [PostalCode] NVARCHAR(10),
    [Phone] NVARCHAR(24),
    [Fax] NVARCHAR(24),
    [Email] NVARCHAR(60)  NOT NULL,
    [SupportRepId] INTEGER,
    CONSTRAINT [PK_Customer] PRIMARY KEY  ([CustomerId]),
    FOREIGN KEY ([SupportRepId]) REFERENCES [Employee] ([EmployeeId]) 
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_CustomerSupportRepId] ON [Customer] ([SupportRepId]);
sqlite> select Customer.Email, Invoice.InvoiceId
   ...> from [Customer]
   ...> join [Invoice]
   ...> on Invoice.CustomerId = Customer.CustomerId
   ...> where Customer.Email = 'hholy@gmail.com';
hholy@gmail.com|46
hholy@gmail.com|175
hholy@gmail.com|198
hholy@gmail.com|220
hholy@gmail.com|272
hholy@gmail.com|393
hholy@gmail.com|404
#+end_src

Same thing using *Subqueries*:
#+begin_src sql
sqlite> select * from [Invoice] where [CustomerId] = (
(x1...>   select [CustomerId] from [Customer] where [Email] = 'hholy@gmail.com'
(x1...> );
46|6|2009-07-11 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|8.91
175|6|2011-02-15 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|1.98
198|6|2011-05-20 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|3.96
220|6|2011-08-22 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|5.94
272|6|2012-04-11 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|0.99
393|6|2013-10-03 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|1.98
404|6|2013-11-13 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|25.86
#+end_src

* Building a a project with Node and SQLite
No setup from scratch, start with a dedicated [[https://github.com/btholt/sqlite-app][githup repo]].
Ideally from a Podman container üòá.
** Tasks
*** DONE I remove the .git files from this repo and integrate into this one.
*** TODO Create a podman container
Not happening üòÖ.
*** DONE Remove dependencies (e.g. no need of nodemon anymore)
*** DONE Make it strippable Typescript files
*** DONE Use a compose file instead of huge build script
*** DONE Adding Node permissions features
Works but outside of podman container.
** Podman container
Doesn't work for many reasons:
- Trying to set up too much stuff with permissions
- Port transpose doesn't seem to work.
  Maybe default values not right or podman desktop setting up wrong stuff.
** Running the App
I'll keep it simple and not use containers.
Run with permissions on my local is fine so I'll keep it at that.
~npm run app~ is good enough.
** schemas of the tables
#+begin_src sql
sqlite> .schema Invoice
CREATE TABLE [Invoice]
(
    [InvoiceId] INTEGER  NOT NULL,
    [CustomerId] INTEGER  NOT NULL,
    [InvoiceDate] DATETIME  NOT NULL,
    [BillingAddress] NVARCHAR(70),
    [BillingCity] NVARCHAR(40),
    [BillingState] NVARCHAR(40),
    [BillingCountry] NVARCHAR(40),
    [BillingPostalCode] NVARCHAR(10),
    [Total] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Invoice] PRIMARY KEY  ([InvoiceId]),
    FOREIGN KEY ([CustomerId]) REFERENCES [Customer] ([CustomerId])
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_InvoiceCustomerId] ON [Invoice] ([CustomerId]);
sqlite> .schema InvoiceLine
CREATE TABLE [InvoiceLine]
(
    [InvoiceLineId] INTEGER  NOT NULL,
    [InvoiceId] INTEGER  NOT NULL,
    [TrackId] INTEGER  NOT NULL,
    [UnitPrice] NUMERIC(10,2)  NOT NULL,
    [Quantity] INTEGER  NOT NULL,
    CONSTRAINT [PK_InvoiceLine] PRIMARY KEY  ([InvoiceLineId]),
    FOREIGN KEY ([InvoiceId]) REFERENCES [Invoice] ([InvoiceId])
		ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([TrackId]) REFERENCES [Track] ([TrackId])
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_InvoiceLineInvoiceId] ON [InvoiceLine] ([InvoiceId]);
CREATE INDEX [IFK_InvoiceLineTrackId] ON [InvoiceLine] ([TrackId]);
#+end_src

Given an =id=, being an =[Invoice]([InvoiceId])=, list the record of that
invoice along with all the invoice lines attached to that same invoiceId.
For example, =id= is 10.
#+name: Invoice No10
#+begin_src sql
sqlite> .mode table
sqlite> select * from [Invoice] where [InvoiceId] = 10;
+-----------+------------+---------------------+------------------+-------------+--------------+----------------+-------------------+-------+
| InvoiceId | CustomerId |     InvoiceDate     |  BillingAddress  | BillingCity | BillingState | BillingCountry | BillingPostalCode | Total |
+-----------+------------+---------------------+------------------+-------------+--------------+----------------+-------------------+-------+
| 10        | 46         | 2009-02-03 00:00:00 | 3 Chatham Street | Dublin      | Dublin       | Ireland        |                   | 5.94  |
+-----------+------------+---------------------+------------------+-------------+--------------+----------------+-------------------+-------+
#+end_src

And now getting the InvoiceLines from the same =InvoiceId=
#+name: InvoiceLines for InvoideId 10
#+begin_src sql
sqlite> select * from [InvoiceLine] where InvoiceLine.InvoiceId = 10;
+---------------+-----------+---------+-----------+----------+
| InvoiceLineId | InvoiceId | TrackId | UnitPrice | Quantity |
+---------------+-----------+---------+-----------+----------+
| 45            | 10        | 248     | 0.99      | 1        |
| 46            | 10        | 252     | 0.99      | 1        |
| 47            | 10        | 256     | 0.99      | 1        |
| 48            | 10        | 260     | 0.99      | 1        |
| 49            | 10        | 264     | 0.99      | 1        |
| 50            | 10        | 268     | 0.99      | 1        |
+---------------+-----------+---------+-----------+----------+
#+end_src

Combining with [Track] table
#+begin_src sql
sqlite> select * from [InvoiceLine] join [Track] on InvoiceLine.TrackId = Track.TrackId where InvoiceLine.InvoiceId = 10;
+---------------+-----------+---------+-----------+----------+---------+-----------------------------+---------+-------------+---------+---------------+--------------+---------+-----------+
| InvoiceLineId | InvoiceId | TrackId | UnitPrice | Quantity | TrackId |            Name             | AlbumId | MediaTypeId | GenreId |   Composer    | Milliseconds |  Bytes  | UnitPrice |
+---------------+-----------+---------+-----------+----------+---------+-----------------------------+---------+-------------+---------+---------------+--------------+---------+-----------+
| 45            | 10        | 248     | 0.99      | 1        | 248     | Etnia                       | 24      | 1           | 7       | Chico Science | 152555       | 5061413 | 0.99      |
| 46            | 10        | 252     | 0.99      | 1        | 252     | Samba Do Lado               | 24      | 1           | 7       | Chico Science | 227317       | 7541688 | 0.99      |
| 47            | 10        | 256     | 0.99      | 1        | 256     | Sobremesa                   | 24      | 1           | 7       | Chico Science | 240091       | 7960868 | 0.99      |
| 48            | 10        | 260     | 0.99      | 1        | 260     | Sangue De Bairro            | 24      | 1           | 7       | Chico Science | 132231       | 4415557 | 0.99      |
| 49            | 10        | 264     | 0.99      | 1        | 264     | Amor De Muito               | 24      | 1           | 7       | Chico Science | 175333       | 5881293 | 0.99      |
| 50            | 10        | 268     | 0.99      | 1        | 268     | Maracatu At√¥mico [Trip Hop] | 24      | 1           | 7       | Chico Science | 221492       | 7380787 | 0.99      |
+---------------+-----------+---------+-----------+----------+---------+-----------------------------+---------+-------------+---------+---------------+--------------+---------+-----------+
#+end_src

Combining with [Album] table
#+begin_src sql
sqlite> select * from [InvoiceLine] join [Track] on InvoiceLine.TrackId = Track.TrackId join [Album] on Track.AlbumId = Album.AlbumId where InvoiceLine.InvoiceId = 10;
+---------------+-----------+---------+-----------+----------+---------+-----------------------------+---------+-------------+---------+---------------+--------------+---------+-----------+---------+----------------+----------+
| InvoiceLineId | InvoiceId | TrackId | UnitPrice | Quantity | TrackId |            Name             | AlbumId | MediaTypeId | GenreId |   Composer    | Milliseconds |  Bytes  | UnitPrice | AlbumId |     Title      | ArtistId |
+---------------+-----------+---------+-----------+----------+---------+-----------------------------+---------+-------------+---------+---------------+--------------+---------+-----------+---------+----------------+----------+
| 45            | 10        | 248     | 0.99      | 1        | 248     | Etnia                       | 24      | 1           | 7       | Chico Science | 152555       | 5061413 | 0.99      | 24      | Afrociberdelia | 18       |
| 46            | 10        | 252     | 0.99      | 1        | 252     | Samba Do Lado               | 24      | 1           | 7       | Chico Science | 227317       | 7541688 | 0.99      | 24      | Afrociberdelia | 18       |
| 47            | 10        | 256     | 0.99      | 1        | 256     | Sobremesa                   | 24      | 1           | 7       | Chico Science | 240091       | 7960868 | 0.99      | 24      | Afrociberdelia | 18       |
| 48            | 10        | 260     | 0.99      | 1        | 260     | Sangue De Bairro            | 24      | 1           | 7       | Chico Science | 132231       | 4415557 | 0.99      | 24      | Afrociberdelia | 18       |
| 49            | 10        | 264     | 0.99      | 1        | 264     | Amor De Muito               | 24      | 1           | 7       | Chico Science | 175333       | 5881293 | 0.99      | 24      | Afrociberdelia | 18       |
| 50            | 10        | 268     | 0.99      | 1        | 268     | Maracatu At√¥mico [Trip Hop] | 24      | 1           | 7       | Chico Science | 221492       | 7380787 | 0.99      | 24      | Afrociberdelia | 18       |
+---------------+-----------+---------+-----------+----------+---------+-----------------------------+---------+-------------+---------+---------------+--------------+---------+-----------+---------+----------------+----------+
#+end_src
* Views
A request that combines multiple tables can come up very frequently.
E.g. listing the name of the artist with the title of a song and the album.
That would be 3 tables very frequently joined. The idea of views is to create
a virtual table that combines those tables and make request on that view
directly.
#+name: Select on multiple table
#+begin_src sql
  select
    Track.TrackId as TrackId,
    Artist.Name as ArtistName,
    Album.Title as AlbumTitle,
    Track.Name as TrackName
  from [Track]
  join [Album]  on Track.AlbumId   = Album.AlbumId
  join [Artist] on Artist.ArtistId = Album.ArtistId
  limit 5;
1|AC/DC|For Those About To Rock We Salute You|For Those About To Rock (We Salute You)
2|Accept|Balls to the Wall|Balls to the Wall
3|Accept|Restless and Wild|Fast As a Shark
4|Accept|Restless and Wild|Restless and Wild
5|Accept|Restless and Wild|Princess of the Dawn
#+end_src

#+name: creating the table
#+begin_src sql
  create view easy_tracks as
  select
    Track.TrackId as TrackId,
    Artist.Name as ArtistName,
    Album.Title as AlbumTitle,
    Track.Name as TrackName
  from [Track]
  join [Album]  on Track.AlbumId   = Album.AlbumId
  join [Artist] on Artist.ArtistId = Album.ArtistId;
#+end_src

#+name: request on views
#+begin_src sql
  select * from easy_tracks
  limit 10;
1|AC/DC|For Those About To Rock We Salute You|For Those About To Rock (We Salute You)
2|Accept|Balls to the Wall|Balls to the Wall
3|Accept|Restless and Wild|Fast As a Shark
4|Accept|Restless and Wild|Restless and Wild
5|Accept|Restless and Wild|Princess of the Dawn
6|AC/DC|For Those About To Rock We Salute You|Put The Finger On You
7|AC/DC|For Those About To Rock We Salute You|Let's Get It Up
8|AC/DC|For Those About To Rock We Salute You|Inject The Venom
9|AC/DC|For Those About To Rock We Salute You|Snowballed
10|AC/DC|For Those About To Rock We Salute You|Evil Walks
#+end_src

‚ö†Ô∏è Every request on a views runs the whole join used to create the view.
A view as a real table is called a *materialised* view.
‚ö†Ô∏è You cannot write in a view.
* Indexes
To view the indexes for a specific table, use ~index_list~
#+begin_src sql
sqlite> pragma index_list('Track');
0|IFK_TrackMediaTypeId|0|c|0
1|IFK_TrackGenreId|0|c|0
2|IFK_TrackAlbumId|0|c|0
#+end_src

They're the foreign keys:
#+begin_src sql
sqlite> .schema Track
CREATE TABLE [Track]
(
    [TrackId] INTEGER  NOT NULL,
    [Name] NVARCHAR(200)  NOT NULL,
    [AlbumId] INTEGER,
    [MediaTypeId] INTEGER  NOT NULL,
    [GenreId] INTEGER,
    [Composer] NVARCHAR(220),
    [Milliseconds] INTEGER  NOT NULL,
    [Bytes] INTEGER,
    [UnitPrice] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Track] PRIMARY KEY  ([TrackId]),
    FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId]) 
		ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([GenreId]) REFERENCES [Genre] ([GenreId]) 
		ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([MediaTypeId]) REFERENCES [MediaType] ([MediaTypeId]) 
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_TrackAlbumId] ON [Track] ([AlbumId]);
CREATE INDEX [IFK_TrackGenreId] ON [Track] ([GenreId]);
CREATE INDEX [IFK_TrackMediaTypeId] ON [Track] ([MediaTypeId]);
#+end_src

Let's create an index on the Name column of the table Track
#+begin_src sql
sqlite> create index idx_track_name on Track (Name);
sqlite> pragma index_list('Track');
0|idx_track_name|0|c|0
1|IFK_TrackMediaTypeId|0|c|0
2|IFK_TrackGenreId|0|c|0
3|IFK_TrackAlbumId|0|c|0

sqlite> explain query plan
   ...> select * from Track
   ...> where name = 'Black Dog';
QUERY PLAN
`--SEARCH Track USING INDEX idx_track_name (Name=?)
#+end_src

Index is the different values of that columns in a B-Tree.
The search happens in the tree first and gives pointers to the rows in the table
with that value. Then the rest of the operations can be performed in that table.
* Full Text Search
There's a pluging called ~Full Text Search, version 5 (FTS5)~ that does exactly
what's in the tin.

#+begin_src sql
sqlite> .tables
Album          Employee       InvoiceLine    PlaylistTrack
Artist         Genre          MediaType      Track        
Customer       Invoice        Playlist       easy_tracks  
sqlite> .schema easy_tracks
CREATE VIEW easy_tracks as
  select
    Track.TrackId as TrackId,
    Artist.Name as ArtistName,
    Album.Title as AlbumTitle,
    Track.Name as TrackName
  from [Track]
  join [Album]  on Track.AlbumId   = Album.AlbumId
  join [Artist] on Artist.ArtistId = Album.ArtistId
/* easy_tracks(TrackId,ArtistName,AlbumTitle,TrackName) */;
sqlite> create virtual table track_search
   ...> using FTS5(content='easy_tracks', content_rowid='TrackId', ArtistName, AlbumTitle, TrackName);
sqlite> .tables
.tables
Album                 InvoiceLine           track_search        
Artist                MediaType             track_search_config 
Customer              Playlist              track_search_data   
Employee              PlaylistTrack         track_search_docsize
Genre                 Track                 track_search_idx    
Invoice               easy_tracks         
#+end_src
The FTS includes the 3 columns ~ArtistName, AlbumTitle, and TrackName~,

The *virtual* table is created empty. Don't forget to fill it in!
#+begin_src sql
sqlite> select * from track_search where track_search match 'black';
-- The virtual table is empty!
sqlite> insert into track_search
   ...> select TrackId, ArtistName, TrackName
   ...> from easy_tracks;
-- And now it works.
sqlite> select * from track_search where track_search match 'black';
Black Label Society|Alcohol Fueled Brewtality Live! [Disc 1]|Intro/ Low Down
Black Label Society|Alcohol Fueled Brewtality Live! [Disc 1]|13 Years Of Grief
Black Label Society|Alcohol Fueled Brewtality Live! [Disc 1]|Stronger Than Death
Black Sabbath|Black Sabbath|N.I.B.
Black Sabbath|Black Sabbath|Evil Woman
Black Sabbath|Black Sabbath|Sleeping Village
Black Sabbath|Black Sabbath Vol. 4 (Remaster)|Changes
Black Sabbath|Black Sabbath Vol. 4 (Remaster)|FX
Black Sabbath|Black Sabbath Vol. 4 (Remaster)|Supernaut
Led Zeppelin|BBC Sessions [Disc 1] [Live]|The Girl I Love She Got Long Black Wavy Hair
Kiss|Greatest Kiss|Black Diamond
Miles Davis|The Essential Miles Davis [Disc 2]|Black Satin
Deep Purple|Knocking at Your Back Door: The Best Of Deep Purple in the 80s|Black Night
Foo Fighters|In Your Honor [Disc 1]|The Deepest Blues Are Black
Incognito|Blue Moods|She Wears Black
James Brown|Sex Machine|Say It Loud, I'm Black And I'm Proud Pt.1
Jamiroquai|Synkronized|Black Capricorn Day
Led Zeppelin|BBC Sessions [Disc 2] [Live]|Black Dog
Led Zeppelin|IV|Black Dog
Led Zeppelin|Led Zeppelin I|Black Mountain Side
Led Zeppelin|Physical Graffiti [Disc 2]|Black Country Woman
Lenny Kravitz|Greatest Hits|Black Velveteen
Metallica|Ride The Lightning|Fade To Black
Pearl Jam|Live On Two Legs [Live]|Black
Pearl Jam|Ten|Black
Soundgarden|A-Sides|Black Hole Sun
Soundgarden|A-Sides|Fell On Black Days
Terry Bozzio, Tony Levin & Steve Stevens|[1997] Black Light Syndrome|Black Light Syndrome
The Black Crowes|Live [Disc 1]|Midnight From The Inside Out
The Black Crowes|Live [Disc 1]|Sting Me
The Black Crowes|Live [Disc 1]|Thick & Thin
The Black Crowes|Live [Disc 1]|Greasy Grass River
The Rolling Stones|Hot Rocks, 1964-1971 (Disc 1)|Paint It Black
The Tea Party|Tangents|Paint It Black
Ozzy Osbourne|Speak of the Devil|Black Sabbath
Amy Winehouse|Back to Black|Back to Black
#+end_src

‚ÑπÔ∏è ~FTS~ is searching in the ~Virtual~ table and returns the rowId that matches.
In then returns the rows in the real table. If the real table is modified, the
two tables are out of sync. The FTS search will match the text available at the
time of creation of the virtual table, but since it returns the rowId, the real
table will return the new values.
So you look for something, find an old match, but still return a new value.
Remember to sync the virtual tables if one of the columns is being impacted by
an update.
‚ö†Ô∏è ~FTS~ is not available in the builtin ~node:sqlite~ module...yet üò•.
* footnotes
[fn:4]Maybe see the PlanetScale course or any other SQL course an the grammar.
I'm only interrested in the *Building an app feature* and don't need to
do a full review of SQL statements building blocks.
[fn:3]At least for now.
[fn:2]It seems there is a convention to put col names and table names
between square brackets.

[fn:1]Depending on your OS, might open Table on Mac, Excel on W$
