#+title: Complete intro to SQLite using Node
#+date: [2025-02-14 Fri]
#+startup: indent
#+property: header-args :results output

* üè∑Ô∏è Complete-Intro-to-SQLite
Front End Masters [[https://frontendmasters.com/courses/sqlite/][course]] by Brian Holt.

* Node app
Since the last version of *Node*, as of today, support TS, I'll just let the IDE
handle the types and run without transpiling.
In the root of the folder:
#+begin_src bash
  nvm install 23
  npm init -y
#+end_src

Some basic settings to begin with:
- Main entry point is =index.ts=. I write directly in typescript and let *Node*
  do the stripping. I will probably have to use only a subset of the TS features
  available.
- Tests will run with the built in test runner ~node --test~.
  *Node* will run against any file that ends with =.test.ts=


Because Typescript doesn't understand *Node* types, I need to also install them.
#+name: install node types
#+begin_src bash
  npm i -D @types/node
#+end_src
* üîë Env
It's all done locally, so no need of handling API Keys of any sort.
* Sqlite command sample
we assume you have the database opened ~sqlite3 ./Chinook_Sqlite.sqlite~.
** Basic builtin commands
- .help :: show the builtin commands available
- .show :: Show the current values for various settings
- .excel :: Display the output of next command in spreadsheet[fn:1]
- .fullschema :: Show schema and the content of sqlite_stat tables
- .schema <pattern> :: Show the CREATE statements matching <pattern>[fn:2]
- .tables <pattern> :: List names of tables matching LIKE pattern TABLE
** SQL commands
I will write the commands in lower case, and respect the schema for table names
and column names (i.e. Same case and between brackets: [Artist]).
There is this rule that says:
- single quotes for strings
- double quotes fol column names
Since I want to use [] for column names, there is simply one rule:
- no double quotes

#+name: open session
#+description: open sqlite session with the Chinook database
#+begin_src bash
  sqlite3 ./Chinook_Sqlite.sqlite
#+end_src

#+name: select
#+begin_src sql
  select * from [Artist]
  select name from [Artist] where [ArtistId] = 174;
  select * from [Artist] where [Name] like '%Postal%';
  select * from [Artist] order by [Name] desc limit 10;
  -- pagination
  select * from [Artist] limit 10; -- page 1
  select * from [Artist] limit 10 offset 10; -- page 2
  select * from [Artist] limit 10 offset 20; -- page 3
#+end_src
** Node:sqlite commands
See [[https://nodejs.org/docs/latest/api/sqlite.html#statementallnamedparameters-anonymousparameters][statement.all]] for an example.

The order of execution is:
1. DatabaseSync with the path to database or ~inMemory~
2. Prepare a request (or any SQL command) into a ~statement~
3. Execute the statement, with:
   - statement.get() :: fetch the first object in the array
   - statement.iterate() :: returns an iterator
   - statement.all() :: returns an array

#+name: example of simlpe node:sqlite statement
#+begin_src javascript
  import { DatabaseSync } from 'node:sqlite'

  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')
  const allPostals = chinookDB.prepare('select * from [Artist] where [Name] like \'%Postal%\'')
  allPostals.all().forEeach(artist => {
    console.info(artist)
  })
#+end_src
* Insert Commands
The [Artist] table has the following schema:
#+name: artist schema
#+begin_src sql
  CREATE TABLE [Artist]
  (
      [ArtistId] INTEGER  NOT NULL,
      [Name] NVARCHAR(120),
      CONSTRAINT [PK_Artist] PRIMARY KEY  ([ArtistId])
  );
#+end_src
The [ArtistId] is generated, so adding a new entry means inserting a new [Name].

#+name: number of entries in [Artist]
#+begin_src sql
  sqlite> select count(*) from [Artist]
  275
#+end_src
** SQL commands
Let's add *Radiohead* to the table
#+name: insert Radiohead
#+begin_src sql
sqlite> insert into [Artist] (name) values ('Radiohead');
#+end_src
No feedback in term of successful insertion ü§∑üèª.

#+name: list last entries
#+begin_src sql
  sqlite> select * from [Artist] order by [ArtistId] desc limit 5;
  276|Radiohead
  275|Philip Glass Ensemble
  274|Nash Ensemble
  273|C. Monteverdi, Nigel Rogers - Chiaroscuro; London Baroque; London Cornett & Sackbu
  272|Emerson String Quartet
#+end_src

** Node:sqlite commands
Does the artist already exist?
#+name: checking duplicates
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')

  const prepFindArtist = chinookDB.prepare(`select * from [Artist] where [Name] = ?`)
  const artistsFound = prepFindArtist.all(name)

  assert.ok(artistsFound.length === 0)
#+end_src

If not then we can add the entry to the table.
#+name: add daft punk
#+begin_src javascript
  const name = 'DaftPunk'
  const prepInsert = chinookDB.prepare(`insert into [Artist] (name) values (?)`)
  const insertLog = prepInsert.run(name)
  console.log(insertLog)
#+end_src

* Update Commands
We want to replace an entry from the [Artist] table.

** SQL command
#+name: from Radiohead to DaftPunk
#+begin_src sql
  sqlite> update [Artist] set [Name] = 'Daft Punk' where [Name] = 'Radiohead' -- Doesn't return anything
  sqlite> update [Artist] set [Name] = 'Justice' where [Name] = 'Daft Punk' returning * -- returns the updated entry
#+end_src


** Node:sqlite commands
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')

  const prepUpdate = chinookDB.prepare('update [Artist] set [Name] = ? where [Name] = ?')
  const updateLog = prepUpdate.run('Daft Punk', 'Radiohead')
  console.log(updateLog)

  chinookDB.close()
#+end_src

* Delete Commands
Let's remove *Radiohead*.

** SQL command
#+name: remove DaftPunk_
#+begin_src sql
  sqlite> delete from [Artist] where [Name] = 'DaftPunk_' returning *;
  278|DaftPunk_
#+end_src

** Node:sqlite command
#+name: remove Justice
#+begin_src javascript
  const name = 'Justice'
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')
  const prepDelete = chinookDB.prepare('delete from [Artist] where [Name] = ? returning *')
  const deleteLog = prepDelete.all(name)
#+end_src

* Creating Tables
There are only 4 datatypes in *SQLite*:
- NULL :: null value
- INTEGER :: signed Int
- REAL :: Floading point value
- TEXT :: text string
- BLOB :: blob of data, like pictures or sound

See [[https://www.sqlite.org/datatype3.html][datatype]] doc.

** SQL command
#+name: creating table and adding a record
#+begin_src sql
  create table [BandMember] (
    [Id]   integer primary key, -- used as rowid
    [Name] text    unique not null,
    [Role] text
  );
  insert into
    [BandMember]
    ([Name], [Role])
  values
    ('Thom Yorke', 'singer'),
    ('Colin Greenwood', 'bassist'),
    ('Ed O''Brien', 'guitarist'),
    ('Philip Selway', 'drummer')
  returning *;
#+end_src

Add a column and drop a column
#+begin_src sql
  alter table [BandMember] add column [Image] BLOB;
  alter table [BandMember] drop column [Image];
  alter table [BandMember] add column [Nationality] TEXT NOT NULL DEFAULT 'UK';
#+end_src

Remove a table
#+begin_src sql
  drop table [BandMember];
#+end_src

* Relational data & Join
The Album table has the following schema:
#+begin_src sql
  sqlite> .schema album
  CREATE TABLE [Album]
  (
      [AlbumId] INTEGER  NOT NULL,
      [Title] NVARCHAR(160)  NOT NULL,
      [ArtistId] INTEGER  NOT NULL,
      CONSTRAINT [PK_Album] PRIMARY KEY  ([AlbumId]),
      FOREIGN KEY ([ArtistId]) REFERENCES [Artist] ([ArtistId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON [Album] ([ArtistId]);
#+end_src

The first few rows look like:
#+begin_src sql
  sqlite> select * from [Album] limit 10;
  1|For Those About To Rock We Salute You|1
  2|Balls to the Wall|2
  3|Restless and Wild|2
  4|Let There Be Rock|1
  5|Big Ones|3
  6|Jagged Little Pill|4
  7|Facelift|5
  8|Warner 25 Anos|6
  9|Plays Metallica By Four Cellos|7
  10|Audioslave|8
#+end_src

The last number is the [ArtistId], that matches the [Artist] ([ArtistId]).
To display the [Name] of the artist instead of the ID:
#+begin_src sql
  sqlite> select Album.AlbumId, Album.Title, Artist.Name
     ...> from [Album] join [Artist] on Album.ArtistId = Artist.ArtistId
     ...> limit 10;
  1|For Those About To Rock We Salute You|AC/DC
  2|Balls to the Wall|Accept
  3|Restless and Wild|Accept
  4|Let There Be Rock|AC/DC
  5|Big Ones|Aerosmith
  6|Jagged Little Pill|Alanis Morissette
  7|Facelift|Alice In Chains
  8|Warner 25 Anos|Ant√¥nio Carlos Jobim
  9|Plays Metallica By Four Cellos|Apocalyptica
  10|Audioslave|Audioslave
#+end_src

** Table alias
Typing the name of the albums all the time can be cumbersome.
There different types of alias:
#+begin_src sql
  sqlite> select Alb.AlbumId, Alb.Title, Art.Name as [artName]
     ...> from [Album] [Alb] join [Artist] [Art] on Alb.ArtistId = Art.ArtistId
     ...> where [artName] = 'Nirvana'
     ...> limit 10;
  163|From The Muddy Banks Of The Wishkah [Live]|Nirvana
  164|Nevermind|Nirvana
#+end_src

** Multiple join
#+begin_src sql
  select art.Name, alb.Title as [Title], trk.Name
  from [Album] [alb]
  join [Artist] [art] on art.ArtistId = alb.ArtistId
  join [Track] [trk]  on trk.AlbumId = alb.AlbumId
  where [Title] = 'Nevermind';
#+end_src

By default this is an *Inner Join*.
- Inner Join :: Include only if this is in both
- Left :: All of *From* table
- Right :: All of the *Join* table
  # You probably don't want to use that one üëáüèª
- Full Outer :: Include all records no matter

*Snow Patrol*:
- has a record in the [Artist] table but
- not in the [Album] table

#+begin_src sql
  sqlite> select * from [Artist] where [Name] = 'Snow Patrol';
  172|Snow Patrol
  sqlite> select * from [Album] where [ArtistId] = 172;
  -- null
#+end_src

With *INNER JOIN*:
#+begin_src sql
  sqlite> select art.Name as [Name], alb.Title
     ...> from [Album] [alb]
     ...> inner join [Artist] [art]
     ...>   on art.ArtistId = alb.ArtistId
     ...> where [Name] = 'Snow Patrol';
  -- null
#+end_src

Same but *RIGHT JOIN*:
#+begin_src sql
  sqlite> select art.Name as [Name], alb.Title
     ...> from [Album] [alb]
     ...> right join [Artist] [art] -- Right Outer Join
     ...>   on art.ArtistId = alb.ArtistId
     ...> where [Name] = 'Snow Patrol';
  Snow Patrol|                    -- There is an art.Name but no alb.Title
#+end_src

List all the artists that do not have an album:
#+begin_src sql
  select art.Name, alb.Title
  from [Artist] [art]
  left outer join [Album] [alb]
    on alb.ArtistId = art.ArtistId
  where alb.ArtistId is null;
#+end_src


* Foreign Keys
They're not enforced by default[fn:3]
See [[https://www.sqlite.org/foreignkeys.html][SQLite Foreign Key Support]].

Enforce foreign key constraint by typing ~sqlite> pragma foreign_keys = on~
#+begin_src sql
  sqlite> .schema Track
  CREATE TABLE [Track]
  (
      [TrackId] INTEGER  NOT NULL,
      [Name] NVARCHAR(200)  NOT NULL,
      [AlbumId] INTEGER,
      [MediaTypeId] INTEGER  NOT NULL,
      [GenreId] INTEGER,
      [Composer] NVARCHAR(220),
      [Milliseconds] INTEGER  NOT NULL,
      [Bytes] INTEGER,
      [UnitPrice] NUMERIC(10,2)  NOT NULL,
      CONSTRAINT [PK_Track] PRIMARY KEY  ([TrackId]),
      FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION,
      FOREIGN KEY ([GenreId]) REFERENCES [Genre] ([GenreId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION,
      FOREIGN KEY ([MediaTypeId]) REFERENCES [MediaType] ([MediaTypeId])
                  ON DELETE NO ACTION ON UPDATE NO ACTION
  );
  CREATE INDEX [IFK_TrackAlbumId] ON [Track] ([AlbumId]);
  CREATE INDEX [IFK_TrackGenreId] ON [Track] ([GenreId]);
  CREATE INDEX [IFK_TrackMediaTypeId] ON [Track] ([MediaTypeId]);

  sqlite> pragma foreign_keys = on;
  sqlite> insert into [Track] ([Name], [AlbumId], [MediaTypeId], [GenreId], [Composer], [Milliseconds], [Bytes], [UnitPrice])
     ...> values ('lol', 9999, 9999, 9999, 9999, 9999, 9999, 9999);
  Runtime error: FOREIGN KEY constraint failed (19)
#+end_src

*AlbumId* is a foreign key
#+begin_src sql
FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
            ON DELETE NO ACTION ON UPDATE NO ACTION,
#+end_src
Looking at the schema, it means to add a new track, you need to ensure that:
- the [AlbumId] value matches an existing [Album] ([AlbumId])
- the [GenreId] value matches an existing [Genre] ([GenreId])
- the [MediaTypeId] value matches an existing [MediaType] ([MediaTypeId])
Since we're adding a Track with the AlbumId 9999 that doesn't exist, it fails.


** Node:sqlite && foreign keys
By default SQLite doesn't enforce foreign keys but *Node:sqlite* does.
See [[https://nodejs.org/docs/latest/api/sqlite.html#new-databasesynclocation-options][DatabaseSync options]]
#+begin_quote
~enableForeignKeyConstraints <boolean>~
If ~true~, foreign key constraints are enabled.
This is recommended but can be disabled for compatibility with legacy database
schemas. The enforcement of foreign key constraints can be enabled and disabled
after opening the database using ~PRAGMA foreign_keys~. Default: ~true~.
#+end_quote

To disable the foreign key constraints:
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite', {
      enableForeignKeyConstraints: false
  })
  // To enable it after opening the database:
const prep = chinookDB.prepare('PRAGMA foreign_keys = ON')
#+end_src

* Aggregation
** count and distinct
#+begin_src sql
sqlite> select count(*) from [Track];
3503
sqlite> select count(distinct [GenreId]) from [Track];
25 -- There are 25 genres
-- How many tracks, per genre?
sqlite> select [GenreId], count([GenreId]) as [Count]
   ...> from [Track]
   ...> group by [GenreId]
   ...> order by [Count] desc;
1|1297
7|579
3|374
4|332
2|130
19|93
6|81
24|74
21|64
14|61
8|58
9|48
10|43
23|40
17|35
15|30
13|28
16|28
20|26
12|24
22|17
11|15
18|13
5|12
25|1
-- Name of the genre instead of the Id
sqlite> select Genre.Name, count(Track.GenreId) as [Count]
   ...> from [Track]
   ...> right join [Genre] on Track.GenreId = Genre.GenreId
   ...> group by Track.GenreId
   ...> order by [Count] desc;
Rock|1297
Latin|579
Metal|374
Alternative & Punk|332
Jazz|130
TV Shows|93
Blues|81
Classical|74
Drama|64
R&B/Soul|61
Reggae|58
Pop|48
Soundtrack|43
Alternative|40
Hip Hop/Rap|35
Electronica/Dance|30
World|28
Heavy Metal|28
Sci Fi & Fantasy|26
Easy Listening|24
Comedy|17
Bossa Nova|15
Science Fiction|13
Rock And Roll|12
Opera|1
#+end_src

** TODO Having[fn:4]
It's ~WHERE~ once the aggregation happened. You cannot refer to any aggregated
value in the ~WHERE~ clause.
#+begin_src sql
sqlite> select Track.GenreId, Genre.Name, count(Track.GenreId) as [Count]
   ...> from [Track]
   ...> join [Genre] on Genre.GenreId = Track.GenreId
   ...> group by Track.GenreId
   ...> Having [Count] > 300;
1|Rock|1297
3|Metal|374
4|Alternative & Punk|332
7|Latin|579
#+end_src

* Subqueries
List the Invoices coming from the same Customer:
#+begin_src sql
sqlite> .schema invoice
CREATE TABLE [Invoice]
(
    [InvoiceId] INTEGER  NOT NULL,
    [CustomerId] INTEGER  NOT NULL,
    [InvoiceDate] DATETIME  NOT NULL,
    [BillingAddress] NVARCHAR(70),
    [BillingCity] NVARCHAR(40),
    [BillingState] NVARCHAR(40),
    [BillingCountry] NVARCHAR(40),
    [BillingPostalCode] NVARCHAR(10),
    [Total] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Invoice] PRIMARY KEY  ([InvoiceId]),
    FOREIGN KEY ([CustomerId]) REFERENCES [Customer] ([CustomerId]) 
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_InvoiceCustomerId] ON [Invoice] ([CustomerId]);
sqlite> .schema customer
CREATE TABLE [Customer]
(
    [CustomerId] INTEGER  NOT NULL,
    [FirstName] NVARCHAR(40)  NOT NULL,
    [LastName] NVARCHAR(20)  NOT NULL,
    [Company] NVARCHAR(80),
    [Address] NVARCHAR(70),
    [City] NVARCHAR(40),
    [State] NVARCHAR(40),
    [Country] NVARCHAR(40),
    [PostalCode] NVARCHAR(10),
    [Phone] NVARCHAR(24),
    [Fax] NVARCHAR(24),
    [Email] NVARCHAR(60)  NOT NULL,
    [SupportRepId] INTEGER,
    CONSTRAINT [PK_Customer] PRIMARY KEY  ([CustomerId]),
    FOREIGN KEY ([SupportRepId]) REFERENCES [Employee] ([EmployeeId]) 
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_CustomerSupportRepId] ON [Customer] ([SupportRepId]);
sqlite> select Customer.Email, Invoice.InvoiceId
   ...> from [Customer]
   ...> join [Invoice]
   ...> on Invoice.CustomerId = Customer.CustomerId
   ...> where Customer.Email = 'hholy@gmail.com';
hholy@gmail.com|46
hholy@gmail.com|175
hholy@gmail.com|198
hholy@gmail.com|220
hholy@gmail.com|272
hholy@gmail.com|393
hholy@gmail.com|404
#+end_src

Same thing using *Subqueries*:
#+begin_src sql
sqlite> select * from [Invoice] where [CustomerId] = (
(x1...>   select [CustomerId] from [Customer] where [Email] = 'hholy@gmail.com'
(x1...> );
46|6|2009-07-11 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|8.91
175|6|2011-02-15 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|1.98
198|6|2011-05-20 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|3.96
220|6|2011-08-22 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|5.94
272|6|2012-04-11 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|0.99
393|6|2013-10-03 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|1.98
404|6|2013-11-13 00:00:00|Rilsk√° 3174/6|Prague||Czech Republic|14300|25.86
#+end_src
* Footnotes
[fn:4]Maybe see the PlanetScale course or any other SQL course an the grammar.
I'm only interrested in the *Building an app feature* and don't need to
do a full review of SQL statements building blocks.

[fn:3]At least for now.
[fn:2]It seems there is a convention to put col names and table names
between square brackets.

[fn:1]Depending on your OS, might open Table on Mac, Excel on W$
