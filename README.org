#+title: Complete intro to SQLite using Node
#+date: [2025-02-14 Fri]
#+startup: indent
#+property: header-args :results output

* üè∑Ô∏è Complete-Intro-to-SQLite
Front End Masters [[https://frontendmasters.com/courses/sqlite/][course]] by Brian Holt.

* Node app
Since the last version of *Node*, as of today, support TS, I'll just let the IDE
handle the types and run without transpiling.
In the root of the folder:
#+begin_src bash
  nvm install 23
  npm init -y
#+end_src

Some basic settings to begin with:
- Main entry point is =index.ts=. I write directly in typescript and let *Node*
  do the stripping. I will probably have to use only a subset of the TS features
  available.
- Tests will run with the built in test runner ~node --test~.
  *Node* will run against any file that ends with =.test.ts=


Because Typescript doesn't understand *Node* types, I need to also install them.
#+name: install node types
#+begin_src bash
  npm i -D @types/node
#+end_src
* üîë Env
It's all done locally, so no need of handling API Keys of any sort.
* Sqlite command sample
we assume you have the database opened ~sqlite3 ./Chinook_Sqlite.sqlite~.
** Basic builtin commands
- .help :: show the builtin commands available
- .show :: Show the current values for various settings
- .excel :: Display the output of next command in spreadsheet[fn:1]
- .fullschema :: Show schema and the content of sqlite_stat tables
- .schema <pattern> :: Show the CREATE statements matching <pattern>[fn:2]
- .tables <pattern> :: List names of tables matching LIKE pattern TABLE
** SQL commands
I will write the commands in lower case, and respect the schema for table names
and column names (i.e. Same case and between brackets: [Artist]).
There is this rule that says:
- single quotes for strings
- double quotes fol column names
Since I want to use [] for column names, there is simply one rule:
- no double quotes

#+name: open session
#+description: open sqlite session with the Chinook database
#+begin_src bash
  sqlite3 ./Chinook_Sqlite.sqlite
#+end_src

#+name: select
#+begin_src sql
  select * from [Artist]
  select name from [Artist] where [ArtistId] = 174;
  select * from [Artist] where [Name] like '%Postal%';
  select * from [Artist] order by [Name] desc limit 10;
  -- pagination
  select * from [Artist] limit 10; -- page 1
  select * from [Artist] limit 10 offset 10; -- page 2
  select * from [Artist] limit 10 offset 20; -- page 3
#+end_src
** Node:sqlite commands
See [[https://nodejs.org/docs/latest/api/sqlite.html#statementallnamedparameters-anonymousparameters][statement.all]] for an example.

The order of execution is:
1. DatabaseSync with the path to database or ~inMemory~
2. Prepare a request (or any SQL command) into a ~statement~
3. Execute the statement, with:
   - statement.get() :: fetch the first object in the array
   - statement.iterate() :: returns an iterator
   - statement.all() :: returns an array

#+name: example of simlpe node:sqlite statement
#+begin_src javascript
  import { DatabaseSync } from 'node:sqlite'

  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')
  const allPostals = chinookDB.prepare('select * from [Artist] where [Name] like \'%Postal%\'')
  allPostals.all().forEeach(artist => {
    console.info(artist)
  })
#+end_src
* Insert Commands
The [Artist] table has the following schema:
#+name: artist schema
#+begin_src sql
  CREATE TABLE [Artist]
  (
      [ArtistId] INTEGER  NOT NULL,
      [Name] NVARCHAR(120),
      CONSTRAINT [PK_Artist] PRIMARY KEY  ([ArtistId])
  );
#+end_src
The [ArtistId] is generated, so adding a new entry means inserting a new [Name].

#+name: number of entries in [Artist]
#+begin_src sql
  select count(*) from [Artist] -- 275
#+end_src
** SQL commands
Let's add *Radiohead* to the table
#+name: insert Radiohead
#+begin_src sql
  insert into [Artist] (name) values ('Radiohead');
#+end_src
No feedback in term of successful insertion ü§∑üèª.

#+name: list last entries
#+begin_src sql
  select * from [Artist] order by [ArtistId] desc limit 5;
#+end_src

#+begin_src sql
  276|Radiohead
  275|Philip Glass Ensemble
  274|Nash Ensemble
  273|C. Monteverdi, Nigel Rogers - Chiaroscuro; London Baroque; London Cornett & Sackbu
  272|Emerson String Quartet
#+end_src

** Node:sqlite commands
Does the artist already exist?
#+name: checking duplicates
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')

  const prepFindArtist = chinookDB.prepare(`select * from [Artist] where [Name] = ?`)
  const artistsFound = prepFindArtist.all(name)

  assert.ok(artistsFound.length === 0)
#+end_src

If not then we can add the entry to the table.
#+name: add daft punk
#+begin_src javascript
  const name = 'DaftPunk'
  const prepInsert = chinookDB.prepare(`insert into [Artist] (name) values (?)`)
  const insertLog = prepInsert.run(name)
  console.log(insertLog)
#+end_src

* Update Commands
We want to replace an entry from the [Artist] table.

** SQL command
#+name: from Radiohead to DaftPunk
#+begin_src sql
  update [Artist] set [Name] = 'Daft Punk' where [Name] = 'Radiohead' -- Doesn't return anything
  update [Artist] set [Name] = 'Justice' where [Name] = 'Daft Punk' returning * -- returns the updated entry
#+end_src


** Node:sqlite commands
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')

  const prepUpdate = chinookDB.prepare('update [Artist] set [Name] = ? where [Name] = ?')
  const updateLog = prepUpdate.run('Daft Punk', 'Radiohead')
  console.log(updateLog)

  chinookDB.close()
#+end_src

* Delete Commands
Let's remove *Radiohead*.

** SQL command
#+name: remove DaftPunk_
#+begin_src sql
  delete from [Artist] where [Name] = 'DaftPunk_' returning *; -- 278|DaftPunk_
#+end_src

** Node:sqlite command
#+name: remove Justice
#+begin_src javascript
  const name = 'Justice'
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite')
  const prepDelete = chinookDB.prepare('delete from [Artist] where [Name] = ? returning *')
  const deleteLog = prepDelete.all(name)
#+end_src

* Creating Tables
There are only 4 datatypes in *SQLite*:
- NULL :: null value
- INTEGER :: signed Int
- REAL :: Floading point value
- TEXT :: text string
- BLOB :: blob of data, like pictures or sound

See [[https://www.sqlite.org/datatype3.html][datatype]] doc.

** SQL command
#+name: creating table and adding a record
#+begin_src sql
  create table [BandMember] (
    [Id]   integer primary key, -- used as rowid
    [Name] text    unique not null,
    [Role] text
  );
  insert into
    [BandMember]
    ([Name], [Role])
  values
    ('Thom Yorke', 'singer'),
    ('Colin Greenwood', 'bassist'),
    ('Ed O''Brien', 'guitarist'),
    ('Philip Selway', 'drummer')
  returning *;
#+end_src

Add a column and drop a column
#+begin_src sql
  alter table [BandMember] add column [Image] BLOB;
  alter table [BandMember] drop column [Image];
  alter table [BandMember] add column [Nationality] TEXT NOT NULL DEFAULT 'UK';
#+end_src

Remove a table
#+begin_src sql
  drop table [BandMember];
#+end_src

* Relational data & Join
The Album table has the following schema:
#+begin_src sql
  .schema album
CREATE TABLE [Album]
(
    [AlbumId] INTEGER  NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    CONSTRAINT [PK_Album] PRIMARY KEY  ([AlbumId]),
    FOREIGN KEY ([ArtistId]) REFERENCES [Artist] ([ArtistId])
		ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON [Album] ([ArtistId]);
#+end_src

The first few rows look like:
#+begin_src sql
  select * from [Album] limit 10;
1|For Those About To Rock We Salute You|1
2|Balls to the Wall|2
3|Restless and Wild|2
4|Let There Be Rock|1
5|Big Ones|3
6|Jagged Little Pill|4
7|Facelift|5
8|Warner 25 Anos|6
9|Plays Metallica By Four Cellos|7
10|Audioslave|8
#+end_src

The last number is the [ArtistId], that matches the [Artist] ([ArtistId]).
To display the [Name] of the artist instead of the ID:
#+begin_src sql
  select Album.AlbumId, Album.Title, Artist.Name
  from [Album] join [Artist] on Album.ArtistId = Artist.ArtistId
  limit 10;
1|For Those About To Rock We Salute You|AC/DC
2|Balls to the Wall|Accept
3|Restless and Wild|Accept
4|Let There Be Rock|AC/DC
5|Big Ones|Aerosmith
6|Jagged Little Pill|Alanis Morissette
7|Facelift|Alice In Chains
8|Warner 25 Anos|Ant√¥nio Carlos Jobim
9|Plays Metallica By Four Cellos|Apocalyptica
10|Audioslave|Audioslave
#+end_src

** Table alias
Typing the name of the albums all the time can be cumbersome.
There different types of alias:
#+begin_src sql
  select Alb.AlbumId, Alb.Title, Art.Name as [artName]
  from [Album] [Alb] join [Artist] [Art] on Alb.ArtistId = Art.ArtistId
  where [artName] = 'Nirvana'
  limit 10;
163|From The Muddy Banks Of The Wishkah [Live]|Nirvana
164|Nevermind|Nirvana
#+end_src

** Multiple join
#+begin_src sql
  select art.Name, alb.Title as [Title], trk.Name
  from [Album] [alb]
  join [Artist] [art] on art.ArtistId = alb.ArtistId
  join [Track] [trk]  on trk.AlbumId = alb.AlbumId
  where [Title] = 'Nevermind';
#+end_src

By default this is an *Inner Join*.
- Inner Join :: Include only if this is in both
- Left :: All of *From* table
- Right :: All of the *Join* table
  # You probably don't want to use that one üëáüèª
- Full Outer :: Include all records no matter

*Snow Patrol*:
- has a record in the [Artist] table but
- not in the [Album] table

#+begin_src sql
  select * from [Artist] where [Name] = 'Snow Patrol';
172|Snow Patrol
  select * from [Album] where [ArtistId] = 172;
  -- null
#+end_src

With *INNER JOIN*:
#+begin_src sql
  select art.Name as [Name], alb.Title
  from [Album] [alb]
  inner join [Artist] [art]
    on art.ArtistId = alb.ArtistId
  where [Name] = 'Snow Patrol';
  -- null
#+end_src

Same but *RIGHT JOIN*:
#+begin_src sql
  select art.Name as [Name], alb.Title
  from [Album] [alb]
  right join [Artist] [art] -- Right Outer Join
    on art.ArtistId = alb.ArtistId
  where [Name] = 'Snow Patrol';
Snow Patrol|                    -- There is an art.Name but no alb.Title
#+end_src

List all the artists that do not have an album:
#+begin_src sql
  select art.Name, alb.Title
  from [Artist] [art]
  left outer join [Album] [alb]
    on alb.ArtistId = art.ArtistId
  where alb.ArtistId is null;
#+end_src


* Foreign Keys
They're not enforced by default[fn:3]
See [[https://www.sqlite.org/foreignkeys.html][SQLite Foreign Key Support]].

Enforce foreign key constraint by typing ~sqlite> pragma foreign_keys = on~
#+begin_src sql
  .schema Track
CREATE TABLE [Track]
(
    [TrackId] INTEGER  NOT NULL,
    [Name] NVARCHAR(200)  NOT NULL,
    [AlbumId] INTEGER,
    [MediaTypeId] INTEGER  NOT NULL,
    [GenreId] INTEGER,
    [Composer] NVARCHAR(220),
    [Milliseconds] INTEGER  NOT NULL,
    [Bytes] INTEGER,
    [UnitPrice] NUMERIC(10,2)  NOT NULL,
    CONSTRAINT [PK_Track] PRIMARY KEY  ([TrackId]),
    FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
                ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([GenreId]) REFERENCES [Genre] ([GenreId])
                ON DELETE NO ACTION ON UPDATE NO ACTION,
    FOREIGN KEY ([MediaTypeId]) REFERENCES [MediaType] ([MediaTypeId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_TrackAlbumId] ON [Track] ([AlbumId]);
CREATE INDEX [IFK_TrackGenreId] ON [Track] ([GenreId]);
CREATE INDEX [IFK_TrackMediaTypeId] ON [Track] ([MediaTypeId]);

  pragma foreign_keys = on;
  insert into [Track] ([Name], [AlbumId], [MediaTypeId], [GenreId], [Composer], [Milliseconds], [Bytes], [UnitPrice])
  values ('lol', 9999, 9999, 9999, 9999, 9999, 9999, 9999);
Runtime error: FOREIGN KEY constraint failed (19)
#+end_src

*AlbumId* is a foreign key
#+begin_src sql
FOREIGN KEY ([AlbumId]) REFERENCES [Album] ([AlbumId])
            ON DELETE NO ACTION ON UPDATE NO ACTION,
#+end_src
Looking at the schema, it means to add a new track, you need to ensure that:
- the [AlbumId] value matches an existing [Album] ([AlbumId])
- the [GenreId] value matches an existing [Genre] ([GenreId])
- the [MediaTypeId] value matches an existing [MediaType] ([MediaTypeId])
Since we're adding a Track with the AlbumId 9999 that doesn't exist, it fails.


** Node:sqlite && foreign keys
By default SQLite doesn't enforce foreign keys but *Node:sqlite* does.
See [[https://nodejs.org/docs/latest/api/sqlite.html#new-databasesynclocation-options][DatabaseSync options]]
#+begin_quote
~enableForeignKeyConstraints <boolean>~
If ~true~, foreign key constraints are enabled.
This is recommended but can be disabled for compatibility with legacy database
schemas. The enforcement of foreign key constraints can be enabled and disabled
after opening the database using ~PRAGMA foreign_keys~. Default: ~true~.
#+end_quote

To disable the foreign key constraints:
#+begin_src javascript
  const chinookDB = new DatabaseSync('./Chinook_Sqlite.sqlite', {
      enableForeignKeyConstraints: false
  })
  // To enable it after opening the database:
const prep = chinookDB.prepare('PRAGMA foreign_keys = ON')
#+end_src
* Footnotes

[fn:3]At least for now.
[fn:2]It seems there is a convention to put col names and table names
between square brackets.

[fn:1]Depending on your OS, might open Table on Mac, Excel on W$
